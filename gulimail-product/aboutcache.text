1、每一个需要缓存的数据我们都来指定要放到哪个名字的缓存【缓存的分区按照业务类型分】
2、@cacheable（{"category"}）
    代表当前方法的结果需要缓存，如果缓存中有方法不用调用
    如果缓存中没有，会调用方法，最后将方法的结果放入缓存
3、默认行为
    1）、如果缓存中有，方法不用调用
    2）、key默认自动生成，缓存的名字 SimpleKey （自动生成的key）
    3）、缓存的value值，默认使用 jdk 序列化机制，将序列化后的数据存到redis
    4）、默认 ttl 时间 -1 （过期时间，-1 为永不过期）

  所以需要自定义
    1）、指定生粗鞥的缓存使用的key，key属性指定，接受一个spel表达式
    2）、指定缓存的数据存活时间，配置文件中修改 ttl
    3）、将数据保存为 json 格式

4、开启缓存加注解 @Cacheable(value = "分区名",key = "#root.methodName") #root.methodName 意为用方法名作为缓存名
   开启缓存一致性 失效模式 @CacheEvict(value = "分区名",key = "'要清空的缓存的区域名'")
                双写模式 @cachePut
                多任务模式 @Caching(evict = {
                                  @CacheEvict(value = "分区名",key = "'要清空的缓存的区域名'"),
                                  @CacheEvict(value = "分区名",key = "'要清空的缓存的区域名'")
                          }) 发生修改时，同时清除两个缓存

5、读模式
    缓存穿透：查询一个null数据，没有，导致大量查询数据库操作，数据库崩溃  解决：查询null数据，并缓存。spring.cache.redis.cache-null-values=true
    缓存击穿：大量并发进入同时查过期数据，导致数据库崩溃。解决方案：加锁，只允许一个线程查询数据库，其余等待。在注解上加sync=true（默认不开启，没有加锁）
            @Cacheable(value = "分区名",key = "#root.methodName",sync=true)
    缓存雪崩：大量key同时过期，导致大量请求同时查数据库，数据库奔溃。解决方案：缓存加过期时间。
6、写模式 （缓存与数据库一致）
    1、读写加锁有序进行，适用读多写少的情景。
    2、引用中间件canal，感知到数据库更新去更新缓存
    3、读多写多，直接去数据库查询。

